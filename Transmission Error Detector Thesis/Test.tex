%\documentclass[12pt,a4paper,openright,twoside]{book}
%\usepackage[italian]{babel}
%\usepackage[latin1]{inputenc}
%\usepackage{fancyhdr}
%\usepackage{indentfirst}
%\usepackage{graphicx}
%\usepackage{newlfont}
%\usepackage{amssymb}
%\usepackage{amsmath}
%\usepackage{latexsym}
%\usepackage{amsthm}
%
%\pagestyle{fancy}\addtolength{\headwidth}{20pt}
%\renewcommand{\chaptermark}[1]{\markboth{\thechapter.\ #1}{}}
%\renewcommand{\sectionmark}[1]{\markright{\thesection \ #1}{}}
%\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
%\cfoot{}
%
%\linespread{1.3}  
%
%\begin{document}
%        \begin{chapter}{Test \& valutazioni sperimentali}
%        \usepackage[italian]{babel}
%        \usepackage[latin1]{inputenc}
%        \usepackage{fancyhdr}
%        \usepackage{indentfirst}
%        \usepackage{graphicx}
%        \usepackage{newlfont}
%        \usepackage{amssymb}
%        \usepackage{amsmath}
%        \usepackage{latexsym}
%        \usepackage{amsthm}
%        
%        \pagestyle{fancy}\addtolength{\headwidth}{20pt}
%        \renewcommand{\chaptermark}[1]{\markboth{\thechapter.\ #1}{}}
%        \renewcommand{\sectionmark}[1]{\markright{\thesection \ #1}{}}
%        \rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
%        \cfoot{}

%\linespread{1.3}  
%TEST E VALUTAZIONI SPERIMENTALI}

\begin{chapter}{Test \& valutazioni sperimentali}

Dopo aver illustrato il funzionamento e l'implementazione del TED, passiamo ora ad analizzare i dati relativi alla trasmissione di pacchetti tramite la nostra applicazione.
Lo scopo dei test effettuati è quello di analizzare la QoS del segnale e come può variare in diversi scenari.
Questo ci è utile in quanto, in base ai risultati ottenuti, si può decidere se cambiare NIC per l'invio di determinati pacchetti.


Per poter analizzare 




\begin{section}{Raccolta dati}
Andremo ora a mostrare quali test sono stati effettuati. In particolare mostreremo quali dispositivi sono stati utilizzati per fare le prove, i parametri di valutazione ed i risultati ottenuti.

 
\begin{subsection}{Dispositivi}
Per effettuare delle prove sperimentali, sono stati utilizzati diversi dispositivi. In particolare due per simulare il client ( o nodo mobile ) ed altri per creare traffico nella rete, in modo da impegnare il canale per avere condizioni simili ad un tipico scenario di utilizzo.
Per ogni dispositivo è interessante mostrare per cosa è stato utilizzato. Nel caso di un nodo della rete, mostreremo anche il sistema operativo, il kernel, il processore e scheda di rete.




\begin{paragraph}{ZyXEL NBG4615 v2}
Access point utilizzato durante i test. È stata impostata la modalità Wi-Fi 802.11b/g/n.

\end{paragraph}


\begin{paragraph}{LB-LINK BL-WN151}
Adattatore Wireless USB. Velocità fino a 150Mb/s, supporta 802.11b/g/n.
È stata utilizzata principalmente sui Raspberry, visto che non dispongono di wireless integrato.
\end{paragraph}

\begin{paragraph}{NETGEAR WG111}
Adattatore Wireless USB. Velocità fino a 54Mb/s, supporta 802.11b/g.
Questo adattatore è più lento ed è stato usato sul computer HP quando il wireless integrato dava dei problemi. 

\end{paragraph}

\begin{paragraph}{HP Pavilion dv6 Entertainment PC}
Questo notebook è stato utilizzato come client. Abbiamo montato un kernel versione 4.0.1, modificato tramite la procedura illustrata precedentemente. 
Le specifiche tecniche sono: 
\begin{itemize}
 \item Kernel: Linux versione 4.0.1 modificata.
 \item Processore: Intel Core i5 CPU M 430.
 \item Sistema operativo: Ubuntu 14.04 LTS 64-bit.
 \item Scheda di rete: Broadcom BCM43225 802.11b/g/n.
\end{itemize}

\end{paragraph}

\begin{paragraph}{DELL Latitude E6400}
Anche questo notebook è stato utilizzato come client, e vi è quindi montato un kernel versione 4.0.1 modificato. 
Le specifiche tecniche sono: 
\begin{itemize}
 \item Kernel: Linux versione 4.0.1 modificata.
 \item Processore: Intel Core 2 Duo.
 \item Sistema operativo: Ubuntu 14.04 LTS 32-bit.
 \item Scheda di rete: Intel Corporation WiFi Link 5100 802.11a/g/n.
\end{itemize}

\end{paragraph}


\begin{paragraph}{Raspberry Pi Model 2}
Abbiamo utilizzato questo raspberry per creare traffico sulla rete.
Le specifiche tecniche sono: 
\begin{itemize}
 \item Kernel: Linux versione 3.18.0-20-rpi2.
 \item Processore: 900MHz quad-core ARM Cortex-A7.
 \item Sistema operativo: Raspbian.
 
\end{itemize}

\end{paragraph}


\begin{paragraph}{UDOO Quad}
Abbiamo utilizzato la UDOO per creare traffico sulla rete, insieme ad i raspberry.
Le specifiche tecniche sono: 
\begin{itemize}
 \item Kernel: Kernel Linux 3.0.35.
 \item Processore: Freescale i.MX 6 ARM Cortex-A9 CPU Dual/Quad core 1GHz.
 \item Sistema operativo: UDOObuntu.
 
\end{itemize}

\end{paragraph}



\begin{paragraph}{Raspberry Pi Model B}
Abbiamo utilizzato questo raspberry per creare traffico sulla rete, ma a volte è stato anche utilizzato come server.
Le specifiche tecniche sono: 
\begin{itemize}
 \item Kernel: Kernel Linux 3.18.7+.
 \item Processore: 700 MHz single-core ARM1176JZF-S.
 \item Sistema operativo: Raspbian Wheezy.
\\ 
\end{itemize}

\end{paragraph}


\end{subsection}




\begin{subsection}{Parametri di valutazione}
Per poter analizzare i test in modo ottimale e per avere dei dati su cui lavorare abbiamo deciso di controllare alcuni parametri.
\\
I parametri che ci interessano maggiormente sono:

\begin{itemize}
 \item \textbf{ACK}: se è stato ricevuto un ACK o un NACK da parte dell'AP. 
 \item \textbf{Data}: è dato dalla data e dall'orario di invio del pacchetto.
 \item \textbf{Tempo}: è il tempo in millisecondi tra l'invio del pacchetto e la ricezione della notifica da parte dell'access point.
 \item \textbf{Retry count}: è il numero di tentativi di invio di un determinato pacchetto.
 \item \textbf{Versione IP}: IPv4 o IPv6.
 \item \textbf{Configurazione}: è la configurazione dei dispositivi utilizzati durante l'esperimento.
 \item \textbf{Wait}: indica se la recv è bloccante.
 
\end{itemize}
Abbiamo scelto questi parametri perché ci permettono di poter giudicare in maniera chiara l'andamento dei pacchetti e la situazione della rete.
In particolare sono molto significativi il tempo, l'ACK ed il retry count.
Grazie a questi dati si può analizzare in modo dettagliato la situazione di ogni singolo pacchetto. L'applicazione può leggere l'ACK e successivamente decidere di rimandare il pacchetto in base ai millisecondi passati prima di ricevere la notifica.
Il numero di retry count risulta rilevante per confrontare differenti situazioni di traffico, oppure per notare cosa succede in caso di trasmissione in movimento.


Gli altri parametri che abbiamo deciso di utilizzare hanno un valore più trascurabile per un singolo pacchetto, ma possono diventare eloquenti per analizzare i dati a posteriori.
In particolare si potrebbe notare in base all'orario se c'è un evidente rallentamento della trasmissione. Ad esempio si potrebbe notare come in una zona industriale la QoS migliori durante la sera/notte.


Un altro dato che può essere utilizzato per esaminare i dati raccolti è la versione IP, si può controllare se c'è un differenza notevole tra IPv6 e IPv4 a parità di condizioni.


Le configurazioni, invece, riguardano i dispositivi utilizzati durante un test e lo scenario applicativo. Andremo a mostrare quali configurazioni sono state provate in modo più dettagliato successivamente.
Per quanto riguarda la wait abbiamo deciso di fare sia una recv bloccante che una non bloccante. Abbiamo fatto dei test con entrambe e abbiamo analizzato le differenze, che andremo a descrivere più avanti.

Si potrebbero utilizzare anche altre informazioni ( ad esempio la bitrate ) per analizzare meglio i risultati, che saranno approfondite negli sviluppi futuri.








\end{subsection}

\begin{subsection}{Configurazioni}
Per ottenere dei risultati che potessero rispecchiare un reale utilizzo da parte di un nodo mobile abbiamo creato diverse configurazioni di dispositivi.
In particolare abbiamo deciso di tenere conto di alcuni possibili scenari di utilizzo, che sono:
\begin{itemize}
 \item Dispositivo client in movimento oppure fermo.
 \item Utilizzo indoor o outdoor.
 \item Trasmissione in linea diretta oppure trasmissione con un ostacolo tra nodo mobile ed AP.
 \item Assenza di traffico sulla rete in contrapposizione ad uno o più hosts wireless a creare traffico.
 \item In caso di presenza di nodi sulla rete abbiamo utilizzato anche la distanza e la velocità come parametri.
 \item Trasmissioni ad un host della stessa sottorete oppure ad una rete esterna.
 \item Dimensione dei pacchetti.
\end{itemize}
Dati questi possibili utilizzi, abbiamo creato alcune configurazioni per valutare la qualità del collegamento.
Il nostro interesse si è focalizzato sulla costruzione di un prodotto cartesiano tra tutte le opzioni.
Abbiamo quindi provato col nodo mobile fermo, da solo nella rete ed in linea diretta con l'AP.
In questa configurazione abbiamo anche valutato le possibili differenze in velocità tra recv bloccante e non bloccante. La scelta tra queste due opzioni è stata implementata nell'applicazione di prova che abbiamo creato e che abbiamo descritto precedentemente.
\\
In contrapposizione a questa prima configurazione, abbiamo testato un nodo mobile solitario nella rete, fermo ma con un ostacolo tra lui e l'AP. Come ostacolo è stato scelto un muro, di larghezza di circa 15 centimetri.
\\
Per completare la raccolta dati da analizzare abbiamo fatto altre due configurazioni, andando a modificare quelle precedenti usando il nodo mobile in movimento.
\\
Queste prime configurazioni ci permettono già di raccogliere importanti dati, che però non possono riflettere un reale utilizzo di una applicazione.
Questo perché difficilmente la trasmissione VoIP avverrà con il dispositivo da solo sulla rete, ma la rete potrà essere più o meno congestionata in base al luogo o all'orario.
\\
Per rispondere a questa esigenza abbiamo deciso di fare delle prove con uno o più host attivi sulla rete, in modo che andassero a causare traffico per rallentare il nodo mobile.
\\
Abbiamo quindi creato altre configurazioni, andando in ognuna a modificare il numero di hosts ed altri parametri. Per quanto riguarda gli host li abbiamo lasciati sempre fermi, ma abbiamo modificato la distanza in diverse prove.
In questo modo gli host trasmetteranno più o meno velocemente e vogliamo andare a verificare al client dia più fastidio avere host lenti o veloci. Per controllare le velocità è stata creata una applicazione in grado di stabilire la bitrate. Questa applicazione sarà descritta successivamente.


Analizziamo ora i settaggi che sono stati implementati.
In particolare avremo il nodo mobile fermo ed un host attivo, entrambi in linea diretta con l'access point. Da questa configurazione base abbiamo allontanato l'host, fino a variare la velocità in modo significativo ( anche di un fattore 1/20 ).
\\
Queste ultime configurazione sono state ampliate anche con l'uso della recv prima bloccante, e poi non bloccante.
Invece per quanto riguarda tutte le configurazioni a seguire abbiamo deciso di testare l'applicazione solo con la modalità della recv non bloccante. 
Questo è stato fatto perché i primi dati empirici erano stati raccolti in quel modo e non si voleva quindi andare ad alterare il risultato.
Avendo comunque analizzato separatamente il comportamento bloccante e non, possiamo dare una congettura di quello che può succedere in caso di comportamento non bloccante.
\\
Anche in questo caso, per ogni configurazione creata, ne abbiamo create altre in cui abbiamo scelto parametri diversi.
Quindi per ognuna è stata tenuta una determinata struttura e siamo andati a modificare un parametro alla volta, registrato tutti i dati ottenuti.
\\
Le configurazioni che useremo nel corso delle valutazioni dei risultati sono descritte in appendice.

\end{subsection}




\begin{subsection}{Dettagli implementativi}
Avendo descritto quali parametri e quali configurazioni abbiamo descritto, ci concentriamo ora sulla parte implementativa dei test.
I principali problemi da risolvere in questa parte erano:
\begin{itemize}
 \item Velocità degli hosts.
 \item Salvataggio dei dati.
 \item Elaborazione dei dati.
\end{itemize}
Per quanto riguarda la misurazione della velocità degli hosts, abbiamo creato una semplice applicazione che vada a misurarla.
Per realizzarla abbiamo creato una connessione tra due hosts, un client ed un server.
Abbiamo scelto di realizzare la applicazione tramite socket TCP; è stata comunque implementata anche la versione UDP. 
\\
Il client trasmette un file tramite Wi-Fi ed il server si mette in ascolto e calcola la velocità del client.
Il server è stato collegato all'AP tramite ethernet, e non wireless, per evitare di introdurre eventuali ritardi ed incognite.
Queste misurazioni sono state fatte all'interno della stessa sottorete, per non influenzare i risultati con la velocità della linea ADSL.
Nel server il calcolo è stato realizzato tramite la divisione tra il totale dei bit ricevuti e i secondi necessari per la ricezione.
Il totale dei bit è stato semplicemente ricavato dal totale di tutti i Byte ricevuti, moltiplicati per 8.
I secondi, invece, sono stati ottenuti catturando il tempo prima dell'inizio della ricezione e appena finita la ricezione ( tramite la \emph{time(NULL)} ).
Successivamente è stata fatta la differenza tra i due time ed è stata calcolata la velocità in Mb/s.
Successivamente, alla fine della ricezione di tutti i Byte, è stato catturato il tempo.
\\
La velocità che è stata rilevata non può essere considerata perfetta in quanto ci potrebbero alcuni fattori che possono andare ad alterarla. 
Possiamo però darla per buona perché, per ogni host, è stata misurata più volte ed è stata successivamente scelta la media. 
Inoltre è stata misurata, nella maggior parte dei casi, in una zona poco abitata e di sera o notte, quindi l'interferenza data da altri dispositivi era minima.
\\

Per quanta riguarda il salvataggio dei dati, abbiamo scelto di farlo in un file in formato \emph{JSON}.
Abbiamo scelto il JSON per la facilità di leggere i dati salvati. I dati sono stati salvati come un array di pacchetti, e per ogni pacchetto è stato salvato:
\begin{itemize}
 \item id del pacchetto.
 \item millisecondi tra invio pacchetto e ricezione della notifica.
 \item numero di tentativi di invio.
 \item versione IP.
 \item boolean per ack.
 \item numero della configurazione.
 \item data.
 
\end{itemize}
I dati salvati sono i parametri di valutazione che abbiamo precedentemente scelto.
Per utilizzare il JSON all'interno di C abbiamo incluso una apposita libreria, la \emph{json/json.h}.
\\
Un esempio di file JSON è il seguente:



\begin{lstlisting}[language=json,firstnumber=1]
{ "pacchetti": [ 

	{ "testId": 4713, "type": 6, "ack": true, "time": 0, "retrycount": 0, "ipVersion": "ipv6", "date": "Sat Jun 20 22:53:38 2015\n" },
	{ "testId": 4714, "type": 6, "ack": true, "time": 6, "retrycount": 0, "ipVersion": "ipv6", "date": "Sat Jun 20 22:53:38 2015\n" },
	{ "testId": 4715, "type": 6, "ack": true, "time": 4, "retrycount": 0, "ipVersion": "ipv6", "date": "Sat Jun 20 22:53:38 2015\n" },
	{ "testId": 4716, "type": 6, "ack": true, "time": 11, "retrycount": 0, "ipVersion": "ipv6", "date": "Sat Jun 20 22:53:38 2015\n" },
	{ "testId": 4717, "type": 6, "ack": true, "time": 0, "retrycount": 0, "ipVersion": "ipv6", "date": "Sat Jun 20 22:53:38 2015\n" },
	{ "testId": 4718, "type": 6, "ack": true, "time": 6, "retrycount": 0, "ipVersion": "ipv6", "date": "Sat Jun 20 22:53:38 2015\n" }
  ]
}


\end{lstlisting}


Grazie all'utilizzo di un file JSON per il salvataggio dei dati, ne risulta più semplice l'analisi.
Per poter elaborare i dati abbiamo scelto di creare vari script utilizzando il linguaggio \emph{Python}. 
È stato scelto il Python perché supporta il JSON e perché permette di effettuare tutte le operazioni necessarie in poche righe.
\\
Sono stati realizzati diversi script per svolgere diversi compiti. Ogni script ha uno scopo specifico ( ad esempio calcolare la media dei tempi di notifica, oppure il numero di nack ricevuti ).
Ad ogni script, a meno di casi particolari, viene passato il file JSON ed il numero di configurazione.
Ognuno di questi script andrà ad aprire il file di log, nel quale sono salvati tutti i dati.
Una volta aperto, viene convertito in una serie di elementi di un array JSON.
Ora, grazie alla configurazione passato da comando, sarà possibile andare ad analizzare i dati.
Ad esempio, il file Python per calcolare la media dei tempi di notifica di una certa configurazione è:


\begin{lstlisting}[language=python]
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# all_avg_time.py
import json
import sys

tipo=-1
nPkt=0
numRetry=0
try:
	inputFile=sys.argv[1]
	tipo=int(sys.argv[2])
except:
	sys.exit("missing argument")

with open(inputFile) as data_file:    
    data = json.load(data_file)

for el in data["pacchetti"]:
	if el['type']==tipo:
		if el['ack']== True :
			numRetry=numRetry+el['retrycount']
			nPkt=nPkt+1	
	
avg=float(numRetry)/float(nPkt)
print(avg)


\end{lstlisting}

Sfruttando gli script che abbiamo realizzato siamo in grado di esprimere delle valutazioni su ogni aspetto che volevamo prendere in considerazione.


\end{subsection}


\begin{subsection}{Test effettuati}
Per effettuare i test ci siamo basati sui parametri e sulle configurazioni scelti precedentemente. 
La disposizione tipica della rete è quella in figura~\ref{fig:salaMengo}.


\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{salaMengo}
    \caption{Disposizione dei dispositivi maggiormente utilizzata. R1 ed R2 sono i Raspberry, mentre U è la UDOO.}
     \label{fig:salaMengo}
\end{figure}

In particolare, è stato usato il computer HP per svolgere la maggior parte dei test. 
Per creare del traffico in rete, invece, sono stati generalmente utilizzati il Raspberry Pi 2, la UDOO ed il Raspberry Model B, con l'eventuale aggiunta di altri dispositivi ( come altri portatili o tablet ).
Come server sono stati usati o il Raspberry Model B oppure altri computer.
\\
Le prove sono state svolte principalmente a casa, ma anche presso il laboratorio Ercolani.
Non sono state fatte prove attraverso la rete \emph{ALMAWIFI} in quanto gli access point bloccavano la comunicazione.
Per ovviare al problema è stata creata un rete locale con l'uso del ZyXEL descritto precedentemente.

 
 
 
\end{subsection}


\end{section}


\begin{section}{Analisi dei risultati}
Andiamo ora ad analizzare i risultati ottenuti.
Le analisi che abbiamo effettuato riguardano la qualità della trasmissione, i tempi medi di ricezione di una notifica proveniente dall'access point, il numero medio di NACK ricevuti e la media dei retry per l'invio dei pacchetti.
Andremo anche ad aggiungere una ulteriore analisi per la configurazione in movimento, che saranno i \emph{burst NACK} ( ovvero quanti NACK consecutivi sono notificati ).
\\
Riguardo alla qualità della trasmissione valutiamo se, per ogni test effettuato, vengono rispettate le linee guida di ITU-T G.1010 \cite{ITUTRacc}.
Per rispettare i parametri dettati dall'ITU è necessario avere ritardi inferiori ai 150 ms e numero di pacchetti persi inferiore al 3\% del totale.
\\
Analizzeremo solo alcuni dei risultati ottenuti.
In particolare ci concentreremo su:
\begin{itemize}
 \item \textbf{Dimensione pacchetti}: abbiamo eseguito test spedendo pacchetti di varie dimensioni. In questo caso abbiamo analizzato il funzionamento dell'applicazione in caso di frammentazione. 
 \item \textbf{Confronto tra IPv4 ed IPv6}: abbiamo analizzato i risultati relativi ad IPv4 ed IPv6 per verificare l'eventuale presenza di differenze in ricezione delle notifiche.
 \item \textbf{Interferenza di altri hosts nella rete}: a parità di pacchetti nella rete è interessante notare come varia la qualità della trasmissione a variare del numero degli hosts sulla rete.
 \item \textbf{Interferenza di altri hosts nella rete}: in questo caso vogliamo sapere quanto incide la velocità degli altri hosts sul client. Abbiamo lasciato invariato il numero di hosts ed abbiamo cambiato la loro velocità.
 \item \textbf{Trasmissione in movimento}: dato il possibile utilizzo su un nodo mobile, ci interessa sapere come varia la connessione durante il movimento.
 \end{itemize}
 
Abbiamo deciso di discutere solamente di questi risultati in quanto risultano i più significativi.
Altre prove effettuate sono state spiegate precedentemente e ne sono state anche accennate alcune analisi.
\\
Per quanto riguarda le prove effettuate sulle dimensione dei pacchetti abbiamo inviato dati di 50 Bytes, 1096 Bytes e da 15.000 Bytes.
I pacchetti da 15.000 B sono stati inviati per verificare il comportamento da parte dell'applicazione.
In particolare il risultato è stata la notifica di ogni singolo frame inviato, come è stato anche descritto precedentemente nel capitolo relativo al TED.
Visto questo comportamento, è necessario gestire a livello applicazione l'avvenuta ricezione di tutti i frame.
Questo dettaglio sarà maggiormente spiegato nel capitolo conclusivo e come sviluppo futuro.
\\


Prima di procedere ad illustrare quali conclusioni sono state tratte è necessario soffermarsi sulle analisi fatte.
Per quanto riguarda i tempi di ricezioni della notifica proveniente dall'AP sono stati prese tutte le notifiche arrivate.
Invece per i retry sono state fatte le medie solamente delle notifiche con ACK, in quanto risultano più interessanti di quelle con NACK.
Infine per quanto riguarda i NACK è stata fatta una media di pacchetti persi su tutti quelli inviati.
Quest'ultima analisi è importante per conoscere la qualità del segnale, insieme ai millisecondi di ricezione della notifica.

Le tabelle che andranno a contenere i dati sono strutturate principalmente con il numero della configurazione su di un asse e il numero della prova sull'altro.
Per quanto riguarda le configurazioni sono indicate solo con un identificativo, per conoscere come è strutturata si può consultare l'appendice.
Invece, riguardo al numero della prova, sono state indicate tre o quattro prove effettuate separatamente che andranno a comporre una media.
%MENGO: aggiungere che abbiamo messo solo alcuni dati,



\begin{subsection}{Confronto tra IPv4 e IPv6}
  
  Per quanto riguarda IPv4 ed IPv6, andiamo ad analizzare i risultati relativi ai tempi di ricezione della notifica proveniente dall'access point, la media dei \emph{NACK} e la media dei retry.
  I test effettuati sono stati realizzati con pacchetti di dimensione ridotta, in modo da non avere frammentazione.
  Ci si aspetta che non ci sia differenza tra le due prove.
  \\
  Come primo parametro andiamo a controllare i tempi, in millisecondi, di ricezione della notifica.
  In particolare si possono notare le medie dei tempi di IPv4 nella tabella~\ref{tab:AvgTimeIPv4}, mentre quelle di IPv6 nella tabella~\ref{tab:AvgTimeIPv6}.

  \begin{table}[h]
  \centering
  \caption{Media dei tempi relativi all'utilizzo di IPv4}
  \label{tab:AvgTimeIPv4}
  \begin{tabular}{|l|c|c|c|c|c|}
  \hline
  IPv4  & Conf. 5 & Conf. 6 & Conf. 7  & Conf. 8 & Conf. 9 \\ \hline
  prima  & 6.234  & 5.624 & 5.5952 & 2.8068  & 4.9292\\ \hline
  seconda & 7.8972  & 5.2736 & 4.7432  & 4.5024 &  2.9844\\ \hline
  terza & 7.3208 & 4.0812 & 4.0432 & 6.0316 & 4.7292\\ \hline
  quarta & 7.627 & 5.906  & 3.4704 & 5.7504 & 6.7728  \\ \hline \hline
  Media & 7.26975 & 5.2212  & 4.463 & 4.7728 & 4.8539  \\ \hline
  \end{tabular}
  \end{table}


  \begin{table}[h]
  \centering
  \caption{Media dei tempi relativi all'utilizzo di IPv6}
  \label{tab:AvgTimeIPv6}
  \begin{tabular}{|l|c|c|c|c|c|}
  \hline
  IPv6  & Conf. 5 & Conf. 6 & Conf. 7  & Conf. 8 & Conf. 9 \\ \hline
  prima  & 5.44  & 6.508 & 4.9788 & 5.338 & 6.2316 \\ \hline
  seconda & 6.8998  & 6.5516 & 5.5684  & 4.5024 & 4.7456 \\ \hline
  terza & 6.177 & 6.6788 & 5.9008 & 5.0316 &  6.1744 \\ \hline
  quarta & 5.9642 & 5.6636  & 4.9396 & 5.5612 & 4.0648 \\ \hline \hline
  Media & 6.12025 & 6.3505  & 5.3469 & 5.1083 & 5.3041 \\ \hline
  \end{tabular}
  \end{table}

  Guardando le medie dei tempi si può notare come, effettivamente, non ci sia una sostanziale differenza tra le due versioni. 
  Questo è ragionevole, in quanto nessuna delle due versioni 
  
  in quanto sono stati testati pacchetti di dimensione ridotta, in modo da non avere frammentazione.
  Si possono ora controllare anche le statistiche relative al numero di retry dei pacchetti che ricevono ACK, sia per IPv4 che per IPv6.
  Ci si aspetta anche in questo caso che i valori siano simili.

  \begin{table}[h]
  \centering
  \caption{Media dei retry relativi all'utilizzo di IPv4}
  \label{tab:AvgRetryIPv4}
  \begin{tabular}{|l|c|c|c|c|c|}
  \hline
  IPv4  & Conf. 5 & Conf. 6 & Conf. 7  & Conf. 8 & Conf. 9 \\ \hline
  prima  & 0.03962  & 0.156 & 0.26683 & 0.13731  & 0.127105\\ \hline
  seconda & 0.08884 & 0.16 & 0.1312  & 0.077787 &  0.14097\\ \hline
  terza & 0.08545 & 0.246894 & 0.193264 & 0.1642628 & 0.134454\\ \hline
  quarta & 0.093838 & 0.1536  & 0.242983 & 0.108844 & 0.15459  \\ \hline \hline
  Media & 0.076937 & 0.1791235  &  0.20856925 & 0.12205095 & 0.13927975  \\ \hline
  \end{tabular}
  \end{table}


  \begin{table}[h]
  \centering
  \caption{Media dei retry relativi all'utilizzo di IPv6}
  \label{tab:AvgRetryIPv6}
  \begin{tabular}{|l|c|c|c|c|c|}
  \hline
  IPv6  & Conf. 5 & Conf. 6 & Conf. 7  & Conf. 8 & Conf. 9 \\ \hline
  prima  & 0.09  & 0.14646 & 0.12902 & 0.11765 & 0.1432\\ \hline
  seconda & 0.06521  & 0.0748 & 0.11774  & 0.1144 & 0.17508 \\ \hline
  terza & 0.04641 & 0.0556 & 0.096 & 0.11307 &  0.1484\\ \hline
  quarta & 0.06687 & 0.05682  & 0.08109 & 0.1508 & 0.120144 \\ \hline \hline
  Media & 0.0671225 & 0.08342  & 0.1059625 & 0.12398 & 0.146706  \\ \hline
  \end{tabular}
  \end{table}

  

  Analizzando le medie dei retry dalle tabelle~\ref{tab:AvgRetryIPv4} e~\ref{tab:AvgRetryIPv6} possiamo osservare che effettivamente non ci sono sostanziali differenze.
  L'unica differenza di configurazione è ottenuta nella Conf. 6, ma è dovuta principalmente ad una prova che ha alzato il valore.
  Visto che una singola prova può essere rallentata da diversi fattori, possiamo valutare le medie relative alle diverse versioni come identiche in caso di mancata frammentazione.

  \end{subsection}

  
\begin{subsection}{Valutazione problemi dovuti a pacchetti nella rete} %MENGO: titolo del cazzo
  Un'osservazione riguardo alla qualità del segnale può essere effettuata controllando il numero di pacchetti e di hosts sulla rete.
  In particolare vogliamo analizzare i risultati relativi all'interferenza di un host che trasmette N pacchetti rispetto a K hosts che trasmettono N/K pacchetti ciascuno.
  La prove sono state effettuate con il client da solo nella rete, con un host sulla rete che trasmette 71 MB, con due hosts che trasmettono 36 MB ciascuno e con tre hosts che trasmettono 22 MB ciascuno.
  \\
  Visto che il numero di host aumenta ci si aspetta un ritardo nella trasmissione da parte del client.
  \\
  Per analizzare i test effettuati abbiamo calcolato le medie dei tempi di ricezioni della notifica nei diversi casi.
  
\begin{table}[h]
  \centering
  \caption{Media dei tempi relativi al traffico di pacchetti}
  \label{tab:AvgTimePkt}
  \begin{tabular}{|l|c|c|c|c|c|}
  \hline
  
  IPv4  & Conf. 58 & Conf. 63 & Conf. 68 \\ \hline
  prima  & 25.349  & 241.187 & 894 \\ \hline
  seconda & 20.553  & 107.034 & 827  \\ \hline
  terza & 25.094 & 303.938 & 1223 \\ \hline
  quarta & 25.132 & 287.32  & 879   \\ \hline \hline
  Media & 24,032 & 234.86975  & 955.75 \\ \hline
  \end{tabular}
  \end{table}

  È importante sottolineare che i tempi presi in considerazione nella tabella~\ref{tab:AvgTimePkt} sono relativi solamente alle notifiche ricevute mentre tutti gli altri host trasmettevano dati.
  Abbiamo scelto di non considerare le altre notifiche in quanto non avrebbero avuto un significato importante nella nostra analisi.
  Dal grafico~\ref{PktDelay} si possono osservare le percentuali di notifiche che hanno subito un ritardo a causa degli altri hosts.
  È interessante notare come la percentuale cali all'aumentare degli host.
  Questo è dovuto ad un pesante degrado delle prestazioni con conseguente aumento dei tempi di notifica.
  A causa di questo per ogni pacchetto si aspetterà più tempo per la notifica, quindi la percentuale aumenta.
  Inoltre gli altri host hanno mano mano meno dati da inviare quindi ci metteranno meno tempo.

  
  
\begin{figure}
  \centering
  \caption{Percentuale di pacchetti che hanno subito ritardo.} 
    \label{PktDelay}

  \begin{tikzpicture}[font=\small]

    \begin{axis}[
      ybar,
      bar width=20pt,
      xlabel={},
      ylabel={\% notifiche con ritardo},
      ymin=0,
      ytick=\empty,
      xtick=data,
      axis x line=bottom,
      axis y line=left,
      enlarge x limits=0.2,
      symbolic x coords={Conf.58, Conf.63,Conf.68},
      xticklabel style={anchor=base,yshift=-\baselineskip},
      nodes near coords={\pgfmathprintnumber\pgfplotspointmeta\%}
    ]
      \addplot[fill=orange] coordinates {
        (Conf.58,10)
        (Conf.63,3)
        (Conf.68,0.3)
      };

      \end{axis}
  \end{tikzpicture}
\end{figure}


  Analizzando i tempi della tabella~\ref{tab:AvgTimePkt} possiamo notare come all'aumentare degli hosts i tempi medi di ricezione di notifica crescano rapidamente.
  È un comportamento interessante in quanto il numero pacchetti totali all'interno della rete rimane invariato.
  Questo andamento è dovuto alla politica di accesso al mezzo adottata dal IEEE802.11, come spiegato precedentemente nel primo capitolo.
 
 
 
   
  Abbiamo inoltre analizzato la QoS, in particolare con riferimento ai tempi.
  Dall'analisi effettuata abbiamo riscontrato un numero di notifiche con ritardo superiore a 150 ms di circa il 5\% nel caso della Conf. 58, mentre nelle Conf. 63 e 68 le percentuali si alzano rispettivamente fino al 90\% ed al 100\%.

  
  
  
  
 
\end{subsection}


\begin{subsection}{Valutazione interferenza traffico} %MENGO: altro titolo del cazzo
  Visto che durante una trasmissione, molto probabilmente, ci saranno anche altri hosts sulla rete, vogliamo capire come possano interferire con il client.
  In particolare ci vogliamo soffermare sulla velocità di trasmissione degli altri nodi.
  L'aspetto che vogliamo esaminare è se il nodo mobile è maggiormente disturbato da nodi che trasmettono a velocità più alta o più bassa, a parità di numero di hosts.
  Ci si potrebbe aspettare che il client non venga influenzato in maniera significativa.
  \\
  Per poter esprimere un valutazione empirica ci concentriamo sui tempi medi di ricezione di una notifica.
  
  \begin{table}[h]
  \centering
  \caption{Media dei tempi nel traffico}
  \label{tab:AvgTimeMbs}
  \begin{tabular}{|l|c|c|c|c|c|}
  \hline
  
    & Conf. 98 & Conf. 93 & Conf. 94  \\ \hline
  prima  & 1,305  & 3,66 & 9.857 \\ \hline
  seconda & 1,724  & 4,259 & 13.869 \\ \hline
  terza & 1,683 & 3,5456 & 11.149 \\ \hline
  quarta & 1,0746 & 2,861  & 11.51  \\ \hline \hline
  Media & 1,44665 & 3,5814  & 11.59625   \\ \hline
  \end{tabular}
  \end{table}
 
 

  Dai tempi in tabella~\ref{tab:AvgTimeMbs} si può notare come, in realtà, ci sia un cospicuo aumento del tempo medio di ricezione di una notifica al diminuire della velocità di trasmissione dell'altro host.
  Una possibile spiegazione è data dal maggior tempo che impiega l'host a velocità ridotta per inviare il proprio frame.
  Occupando il canale per più tempo viene, ovviamente, rallentato il client.
  
 
 
  In questo caso l'applicazione non può intervenire per migliorare la connessione in quanto il problema è dovuto ad altri dispositivi.
  L'applicazione può, però, capire il degrado della rete e cambiare NIC se la situazione diventa insostenibile per la comunicazione.

  
 
  Andiamo ora ad analizzare la qualità della trasmissione.
  Per farlo abbiamo calcolato la percentuale di notifiche con ritardo superiore ai 150 ms, i cui risulati sono rappresentati nella figura~\ref{QoSLossTraf}.
  \begin{figure}[width=1\textwidth]
   \centering
   \caption{Percentuale notifiche con ritardo per QoS per traffico.}
    \label{QoSLossTraf}
    
   \begin{tikzpicture}[font=\small, width=1\textwidth]
   \pie[cloud, text=legend, scale font, width=1\textwidth]
     {
        0.03/Conf98, 0.47/Conf93,1.41/Conf94
     }
   
   \end{tikzpicture}
  
 \end{figure}


   
  Come si può notare la percentuale è molto bassa nel caso di assenza di altri hosts nella rete, mentre si registra un aumento in caso di una presenza da parte di un altro host.
  In particolare si ha un incremento maggiore se l'altro host trasmette ad una velocità più bassa.
  
  
 
\end{subsection}



\begin{subsection}{Problemi dovuti alla trasmissione in movimento}
 
  Riguardo la trasmissione in movimento, rispetto a quella da fermo, è interessante notare alcuni aspetti.
  È innanzitutto fondamentale sottolineare la tipologia di movimento effettuata.
  In particolare ci siamo concentrati su di un movimento che ci portasse dietro ad un ostacolo, questo perché volevamo capire come potesse variare la connessione.
  Abbiamo fatto anche alcuni test, per completezza, con un movimento che portasse il client ad essere sempre il linea di vista con l'access point ed ad una distanza accettabile.
  I risultati sono, come preventivabile, pressoché indifferenti rispetto ad una trasmissione da fermo. 
  Questo comportamento è dovuto alla bassa velocità data da un movimento a piedi, che non va ad incidere sulla connessione creata tra client e AP.
  \\
  I dati su cui ci vogliamo soffermare, invece, sono quelli riguardanti il movimento dietro ad un ostacolo.
  A causa dell'ostacolo ci aspettiamo di avere un peggioramento della connessione.
  \\
  Il test è stato strutturato ponendo prima il nodo mobile da solo, poi con altri hosts sulla rete.
  Gli altri hosts hanno la funzione di creare traffico.
  Tutti i dettagli sono descritti in appendice.
  \\
  Per analizzare in maniera dettagliata i risultati ottenuti ci siamo inizialmente concentrati su un'analisi delle medie dei tempi e dei retry di trasmissioni da fermo ed in movimento.
  Le statistiche dei tempi sono indicate nelle tabelle~\ref{tab:AvgTimeStay} e~\ref{tab:AvgTimeMove}.

  \begin{table}[h]
  \centering
  \caption{Media dei tempi con nodo mobile fermo}
  \label{tab:AvgTimeStay}
  \begin{tabular}{|l|c|c|c|c|c|}
  \hline
   & Conf. 83A & Conf. 85A & Conf. 87A \\ \hline
  prima  & 0.768  & 12.986 & 26.799  \\ \hline
  seconda & 0.748  & 9.362 & 56.85   \\ \hline
  terza & 0.696 & 7.941 & 80.897  \\ \hline
  quarta & 0.662 & 9.295  & 73.785   \\ \hline \hline
  Media & 0.7185 & 9.896  & 62.08275   \\ \hline
  \end{tabular}
  \end{table}


  \begin{table}[h]
  \centering
  \caption{Media dei tempi con nodo mobile in movimento}
  \label{tab:AvgTimeMove}
  \begin{tabular}{|l|c|c|c|c|c|}
  \hline
    & Conf. 83B & Conf. 85B & Conf. 87B    \\ \hline
  prima  & 0.987  & 17.524 & 45.909  \\ \hline
  seconda & 1.13  & 15.021 & 36.636   \\ \hline
  terza & 0.9628 & 50.244 &  57.399 \\ \hline
  quarta & 1.064 & 45.503  & 96.327 \\ \hline \hline
  Media & 1.03595 & 21.986  & 59.06775   \\ \hline
  \end{tabular}
  \end{table}  
  
  Come si può notare, c'è stato un peggioramento sia nella Conf.83 che nella conf.85.
  Sono invece rimasti circa identici i tempi della Conf.87.
  Questo può essere dovuto ad una rete già congestionata, che porta il movimento ad incidere di meno nella qualità.
  
  
  Per approfondire meglio l'analisi valutiamo il numero medio di retry avuti per i pacchetti con ACK.
  Visti i comportamenti nei tempi ci aspettiamo lo stesso cambiamento anche nei retry, i cui dati sono riferiti nelle tabelle~\ref{tab:AvgRetryStay} e~\ref{tab:AvgRetryMove}.
  

  
  \begin{table}[h]
  \centering
  \caption{Media dei retry con nodo mobile fermo}
  \label{tab:AvgRetryStay}
  \begin{tabular}{|l|c|c|c|c|c|}
  \hline
    & Conf. 83A & Conf. 85A & Conf. 87A \\ \hline
  prima  & 0.0652  & 0.029 & 0.128  \\ \hline
  seconda & 0.0104  & 0.0706 & 0.0961   \\ \hline
  terza & 0.0118 & 0.0302 & 0.108  \\ \hline
  quarta & 0.0124 & 0.0981  & 0.102   \\ \hline \hline
  Media & 0.0245 & 0.056975  & 0.108525   \\ \hline
  \end{tabular}
  \end{table}


  \begin{table}[h]
  \centering
  \caption{Media dei retry con nodo mobile in movimento}
  \label{tab:AvgRetryMove}
  \begin{tabular}{|l|c|c|c|c|c|}
  \hline
    & Conf. 83B & Conf. 85B & Conf. 87B    \\ \hline
  prima  & 0.227 & 0.273 & 0.072  \\ \hline
  seconda & 0.218  & 0.202 & 0.179   \\ \hline
  terza & 0.221 & 0.226 &  0.225 \\ \hline
  quarta & 0.238 & 0.212  & 0.349 \\ \hline \hline
  Media & 0.226 & 0.22825  & 0.20625  \\ \hline
  \end{tabular}
  \end{table}  
  
  A differenza dei tempi, invece, il movimento aumenta il numero medio di retry in tutte le configurazioni testate.
  Un particolare interessante è dato dalla media simile per tutte le prove.
  Empiricamente si potrebbe arrivare alla conclusione che se il client è in movimento e c'è un ostacolo tra lui e l'AP, il numero di retry si alza indipendentemente dal numero di hosts sulla rete.
  
  
  Un altro fondamentale aspetto che possiamo osservare è il dato relativo ai NACK. 
  In particolare è interessante notare il burst NACK, ovvero quanti ne arrivano in modo contiguo.
  Questo aspetto è importante perché, in caso di ostacolo, si può avere un elevato numero di notifiche di questo tipo.
  Il problema di avere NACK a burst è la perdita di informazione durante la trasmissione.
  È infatti più problematico avere N NACK tutti attaccati rispetto allo stesso numero di NACK ma sparsi per tutta la durata della trasmissione.
  Infatti nel secondo caso ci potrebbe essere solo un lieve disturbo nella comunicazione, invece nel primo caso si potrebbe perdere qualche istante di comunicazione.
  Perdendo anche solo qualche istante si potrebbe alterare il senso del discorso ( si pensi ad esempio alla perdita di una negazione all'interno di una frase ).
  
  
\begin{figure}
  \centering
  \caption{Massimo numero di NACK consecutivi.}
   \label{MaxBurstNackIsto}
   
  \begin{tikzpicture}[font=\small]
    
    \begin{axis}[
      ybar,
      bar width=20pt,
      xlabel={},
      ylabel={numero max di nack consecutivi},
      ymin=0,
      ytick=\empty,
      xtick=data,
      axis x line=bottom,
      axis y line=left,
      enlarge x limits=0.2,
      symbolic x coords={Conf.83, Conf.85,Conf.87},
      xticklabel style={anchor=base,yshift=-\baselineskip},
      nodes near coords={\pgfmathprintnumber\pgfplotspointmeta}
    ]
      \addplot[fill=blue] coordinates {
        (Conf.83,1)
        (Conf.85,2)
        (Conf.87,4)
      };
      \addplot[fill=yellow] coordinates {
        (Conf.83,24)
        (Conf.85,33)
        (Conf.87,29)
      };

      \end{axis}
  \end{tikzpicture}
 
\end{figure}


  
  Per analizzare i test effettuati usiamo il grafico~\ref{MaxBurstNackIsto}.
  Per ogni configurazione viene mostrato il massimo numero di NACK consecutivi, sia nel caso di trasmissione da fermo ( colore blu) che in movimento ( colore giallo ).
  Come si può notare, nel caso di movimento c'è un elevato numero di NACK a burst.
  Si può inoltre notare che non dipende dal numero di dispotivi in rete ma dall'eventuale presenza di ostacolo, ricordando che stiamo analizzando solo il caso di movimento in presenza di ostacolo.
  Oltre a questi casi di massimi ci sono stati altri valori alti di NACK contigui.
  
  
  
  Questa conclusione è molto importante in quanto se il client, durante un movimento, si mette in una condizione sfavorevole andando dietro ad un ostacolo la qualità della trasmissione peggiora sensibilmente.
  \\
  In questa situazione l'applicazione dovrebbe cambiare NIC per continuare ad avere una buona QoS.
  Se il client ha dei sensori di movimento incorporati, potrebbe sfruttarli per migliorare le proprie prestazioni.
  In particolare se i sensori rilevano uno spostamento e durante questo movimento si iniziano a ricevere alcuni ack, il dispositivo potrebbe capire che c'è un ostacolo tra lui e l'access point.
  A questo punto può inviare i prossimi N pacchetti con un'altra NIC, per poi provare di nuovo con il Wi-Fi precedente.
  Se invece ad un certo punto rileva un movimento contrario a quello che ha portato il peggioramento della connessione, potrebbe capire quando il segnale può tornare ad essere buono.
  \\
  Implementando questo tipo di meccanismo l'applicazione potrebbe migliorare sensibilmente la qualità della propria trasmissione, evitando NACK a burst.
  
  
  
\begin{figure}
   \centering
   \caption{Percentuale notifiche con ritardo per QoS in movimento.}
    \label{QoSTimeMove}
    
   \begin{tikzpicture}[font=\small]
   \pie[cloud, text=legend, scale font, width=1\textwidth]
     {
        1.324/Conf85A, 2.78/Conf85B,5.31/Conf87A, 6.91/Conf87B %0.0/Conf83A, 0.0186/Conf83B,
     }
   
   \end{tikzpicture}
  
 \end{figure}
 

 Come ultima analisi andiamo a valutare la QoS della trasmissione.
 In questo caso abbiamo considerato sia i tempi che il numero di pacchetti persi.
 Per quanto riguarda i tempi abbiamo calcolato la percentuale di notifiche con ritardo superiore ai 150 ms e abbiamo inserito i dati nel grafico~\ref{QoSTimeMove}.
 In tale grafico, però, non compaiono i dati relativi alle configurazioni 83A ed 83B in quanto sono prossime allo zero.
 Analizzando le statistiche si può innanzitutto notare come ci sia una notevole differenza tra le configurazioni 83A, 85A ed 87A.
 Questo è dovuto al maggior traffico che viene creato sulla rete, che porta ad un significativo rallentamento della trasmissione da parte del nodo mobile.
 Andando invece ad esaminare il caso di trasmissione in movimento si può notare come le percentuali subiscano quasi un raddoppio rispetto al caso da fermo.
 \\
\begin{figure}
   \centering
   \caption{Percentuale pacchetti per QoS in movimento.}
    \label{QoSLossMove}
    
   \begin{tikzpicture}[font=\small]
   \pie[cloud, text=legend, scale font, width=1\textwidth]
     {
        2.159/Conf83B, 3.476/Conf85B,4.512/Conf87B
     }
   
   \end{tikzpicture}
  
 \end{figure}

 Riguardo ai pacchetti persi abbiamo seguito un procedimento simile ed abbiamo inserito i dati nel grafico~\ref{QoSLossMove}.
 Nel grafico sono state indicate solo le statistiche relative alla trasmissione in movimento visto che per le trasmissioni da fermo i dati erano intorno allo zero e quindi ben sotto la soglia.
 In caso, invece, di trasmissione con nodo mobile in movimento le percentuali subiscono un sostanziale aumento e si supera la soglia del 3\% nel caso di trasmissione con due hosts.
 \\
 
 Dalle valutazioni che abbiamo fatto precedentemente, quindi, si può stabilire che l'elevato numero di NACK dipende principalmente da un movimento da parte del client che porti il nodo ad essere dietro ad un ostacolo.
 In maniera minore, comunque, incide anche il traffico presente nella rete.
 
 
 
 
\end{subsection}




\end{section}




\end{chapter}

%\end{document}
