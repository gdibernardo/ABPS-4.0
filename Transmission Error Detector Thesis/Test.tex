%\documentclass[12pt,a4paper,openright,twoside]{book}
%\usepackage[italian]{babel}
%\usepackage[latin1]{inputenc}
%\usepackage{fancyhdr}
%\usepackage{indentfirst}
%\usepackage{graphicx}
%\usepackage{newlfont}
%\usepackage{amssymb}
%\usepackage{amsmath}
%\usepackage{latexsym}
%\usepackage{amsthm}
%
%\pagestyle{fancy}\addtolength{\headwidth}{20pt}
%\renewcommand{\chaptermark}[1]{\markboth{\thechapter.\ #1}{}}
%\renewcommand{\sectionmark}[1]{\markright{\thesection \ #1}{}}
%\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
%\cfoot{}
%
%\linespread{1.3}  
%
%\begin{document}
%        \begin{chapter}{Test \& valutazioni sperimentali}
%        \usepackage[italian]{babel}
%        \usepackage[latin1]{inputenc}
%        \usepackage{fancyhdr}
%        \usepackage{indentfirst}
%        \usepackage{graphicx}
%        \usepackage{newlfont}
%        \usepackage{amssymb}
%        \usepackage{amsmath}
%        \usepackage{latexsym}
%        \usepackage{amsthm}
%        
%        \pagestyle{fancy}\addtolength{\headwidth}{20pt}
%        \renewcommand{\chaptermark}[1]{\markboth{\thechapter.\ #1}{}}
%        \renewcommand{\sectionmark}[1]{\markright{\thesection \ #1}{}}
%        \rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
%        \cfoot{}

%\linespread{1.3}  
%TEST E VALUTAZIONI SPERIMENTALI}

\begin{chapter}{Test \& valutazioni sperimentali}

Dopo aver illustrato il funzionamento e l'implementazione del TED, passiamo ora ad analizzare i dati relativi alla trasmissione di pacchetti tramite la nostra applicazione.
Lo scopo dei test effettuati è quello di analizzare la QoS del segnale e come può variare in diversi scenari.
Questo ci è utile in quanto, in base ai risultati ottenuti, si può decidere se cambiare NIC per l'invio di determinati pacchetti.


Per poter analizzare 




\begin{section}{Raccolta dati}
Andremo ora a mostrare quali test sono stati effettuati. In particolare mostreremo quali dispositivi sono stati utilizzati per fare le prove, i parametri di valutazione ed i risultati ottenuti.

 
\begin{subsection}{Dispositivi}
Per effettuare delle prove sperimentali, sono stati utilizzati diversi dispositivi. In particolare due per simulare il client ( o nodo mobile ) ed altri per creare traffico nella rete, in modo da impegnare il canale per avere condizioni simili ad un tipico scenario di utilizzo.
Per ogni dispositivo è interessante mostrare per cosa è stato utilizzato. Nel caso di un nodo della rete, mostreremo anche il sistema operativo, il kernel, il processore e scheda di rete.




\begin{paragraph}{ZyXEL NBG4615 v2}
Access point utilizzato durante i test. È stata impostata la modalità Wi-Fi 802.11b/g/n.

\end{paragraph}


\begin{paragraph}{LB-LINK BL-WN151}
Adattatore Wireless USB. Velocità fino a 150Mb/s, supporta 802.11b/g/n.
È stata utilizzata principalmente sui Raspberry, visto che non dispongono di wireless integrato.
\end{paragraph}

\begin{paragraph}{NETGEAR WG111}
Adattatore Wireless USB. Velocità fino a 54Mb/s, supporta 802.11b/g.
Questo adattatore è più lento ed è stato usato sul computer HP quando il wireless integrato dava dei problemi. 

\end{paragraph}

\begin{paragraph}{HP Pavilion dv6 Entertainment PC}
Questo notebook è stato utilizzato come client. Abbiamo montato un kernel versione 4.0.1, modificato tramite la procedura illustrata precedentemente. 
Le specifiche tecniche sono: 
\begin{itemize}
 \item Kernel: Linux versione 4.0.1 modificata.
 \item Processore: Intel Core i5 CPU M 430.
 \item Sistema operativo: Ubuntu 14.04 LTS 64-bit.
 \item Scheda di rete: Broadcom BCM43225 802.11b/g/n.
\end{itemize}

\end{paragraph}

\begin{paragraph}{DELL Latitude E6400}
Anche questo notebook è stato utilizzato come client, e vi è quindi montato un kernel versione 4.0.1 modificato. 
Le specifiche tecniche sono: 
\begin{itemize}
 \item Kernel: Linux versione 4.0.1 modificata.
 \item Processore: Intel Core 2 Duo.
 \item Sistema operativo: Ubuntu 14.04 LTS 32-bit.
 \item Scheda di rete: Intel Corporation WiFi Link 5100 802.11a/g/n.
\end{itemize}

\end{paragraph}


\begin{paragraph}{Raspberry Pi Model 2}
Abbiamo utilizzato questo raspberry per creare traffico sulla rete.
Le specifiche tecniche sono: 
\begin{itemize}
 \item Kernel: Linux versione 3.18.0-20-rpi2.
 \item Processore: 900MHz quad-core ARM Cortex-A7.
 \item Sistema operativo: Raspbian.
 
\end{itemize}

\end{paragraph}


\begin{paragraph}{UDOO Quad}
Abbiamo utilizzato la UDOO per creare traffico sulla rete, insieme ad i raspberry.
Le specifiche tecniche sono: 
\begin{itemize}
 \item Kernel: Kernel Linux 3.0.35.
 \item Processore: Freescale i.MX 6 ARM Cortex-A9 CPU Dual/Quad core 1GHz.
 \item Sistema operativo: UDOObuntu.
 
\end{itemize}

\end{paragraph}



\begin{paragraph}{Raspberry Pi Model B}
Abbiamo utilizzato questo raspberry per creare traffico sulla rete, ma a volte è stato anche utilizzato come server.
Le specifiche tecniche sono: 
\begin{itemize}
 \item Kernel: Kernel Linux 3.18.7+
 \item Processore: 700 MHz single-core ARM1176JZF-S 
 \item Sistema operativo: Raspbian Wheezy
\\ 
\end{itemize}

\end{paragraph}


\end{subsection}




\begin{subsection}{Parametri di valutazione}
Per poter analizzare i test in modo ottimale e per avere dei dati su cui lavorare abbiamo deciso di controllare alcuni parametri.
\\
I parametri che ci interessano maggiormente sono:

\begin{itemize}
 \item \textbf{Id}: l'Id del pacchetto inviato.
 \item \textbf{ACK}: se è stato ricevuto un ACK o un NACK da parte dell'AP. 
 \item \textbf{Data}: è dato dalla data e dall'orario di invio del pacchetto.
 \item \textbf{Tempo}: è il tempo in millisecondi tra l'invio del pacchetto e la ricezione della notifica da parte dell'access point.
 \item \textbf{Retry count}: è il numero di tentativi di invio di un determinato pacchetto
 \item \textbf{Versione IP}: IPv4 o IPv6
 \item \textbf{Configurazione}: è la configurazione dei dispositivi utilizzati durante l'esperimento.
 \item \textbf{Wait}: indica se la recv è bloccante.
 
\end{itemize}
Abbiamo scelto questi parametri perché ci permettono di poter giudicare in maniera chiara l'andamento dei pacchetti e la situazione della rete.
In particolare sono molto significativi il tempo, l'ACK ed il retry count.
Grazie a questi dati si può analizzare in modo dettagliato la situazione di ogni singolo pacchetto. L'applicazione può leggere l'ACK e successivamente decidere di rimandare il pacchetto in base ai millisecondi passati prima di ricevere la notifica.
Il numero di retry count risulta rilevante per confrontare differenti situazioni di traffico, oppure per notare cosa succede in caso di trasmissione in movimento.


Gli altri parametri che abbiamo deciso di utilizzare hanno un valore più trascurabile per un singolo pacchetto, ma possono diventare eloquenti per analizzare i dati a posteriori.
In particolare si potrebbe notare in base all'orario se c'è un evidente rallentamento della trasmissione. Ad esempio si potrebbe notare come in una zona industriale la QoS migliori durante la sera/notte.


Un altro dato che può essere utilizzato per esaminare i dati raccolti è la versione IP, si può controllare se c'è un differenza notevole tra IPv6 e IPv4 a parità di condizioni.


Le configurazioni, invece, riguardano i dispositivi utilizzati durante un test e lo scenario applicativo. Andremo a mostrare quali configurazioni sono state provate in modo più dettagliato successivamente.
Per quanto riguarda la wait abbiamo deciso di fare sia una recv bloccante che una non bloccante. Abbiamo fatto dei test con entrambe e abbiamo analizzato le differenze, che andremo a descrivere più avanti.

Si potrebbero utilizzare anche altre informazioni ( ad esempio la bitrate ) per analizzare meglio i risultati, che saranno approfondite negli sviluppi futuri.








\end{subsection}

\begin{subsection}{Configurazioni}
Per ottenere dei risultati che potessero rispecchiare un reale utilizzo da parte di un nodo mobile abbiamo creato diverse configurazioni di dispositivi.
In particolare abbiamo deciso di tenere conto di alcuni possibili scenari di utilizzo, che sono:
\begin{itemize}
 \item Dispositivo client in movimento oppure fermo.
 \item Utilizzo indoor o outdoor.
 \item Trasmissione in linea diretta oppure trasmissione con un ostacolo tra nodo mobile ed AP.
 \item Assenza di traffico sulla rete in contrapposizione ad uno o più hosts wireless a creare traffico.
 \item Nel caso di presenza di nodi sulla rete, abbiamo utilizzato anche la distanza e la velocità come parametri.
 \item Trasmissioni ad un host della stessa sottorete oppure ad una rete esterna.
\end{itemize}
Dati questi possibili utilizzi, abbiamo creato alcune configurazioni per valutare la qualità del collegamento.
Il nostro interesse si è focalizzato sulla costruzione di un prodotto cartesiano tra tutte le opzioni.
Abbiamo quindi provato col nodo mobile fermo, da solo nella rete ed in linea diretta con l'AP.
In questa configurazione abbiamo anche valutato le possibili differenze in velocità tra recv bloccante e non bloccante. La scelta tra queste due opzioni è stata implementata nell'applicazione di prova che abbiamo creato e che abbiamo descritto precedentemente.
\\
In contrapposizione a questa prima configurazione, abbiamo testato un nodo mobile solitario nella rete, fermo ma con un ostacolo tra lui e l'AP. Come ostacolo è stato scelto un muro, di larghezza di circa 15 centimetri.
\\
Per completare la raccolta dati da analizzare abbiamo fatto altre due configurazioni, andando a modificare quelle precedenti usando il nodo mobile in movimento.
\\
Queste prime configurazioni ci permettono già di raccogliere importanti dati, che però non possono riflettere un reale utilizzo di una applicazione.
Questo perché difficilmente la trasmissione VoIP avverrà con il dispositivo da solo sulla rete, ma la rete potrà essere più o meno congestionata in base al luogo o all'orario.
\\
Per rispondere a questa esigenza abbiamo deciso di fare delle prove con uno o più host attivi sulla rete, in modo che andassero a causare traffico per rallentare il nodo mobile.
\\
Abbiamo quindi creato altre configurazioni, andando in ognuna a modificare il numero di hosts ed altri parametri. Per quanto riguarda gli host li abbiamo lasciati sempre fermi, ma abbiamo modificato la distanza in diverse prove.
In questo modo gli host trasmetteranno più o meno velocemente e vogliamo andare a verificare al client dia più fastidio avere host lenti o veloci. Per controllare le velocità è stata creata una applicazione in grado di stabilire la bitrate. Questa applicazione sarà descritta successivamente.


Analizziamo ora i settaggi che sono stati implementati.
In particolare avremo il nodo mobile fermo ed un host attivo, entrambi in linea diretta con l'access point. Da questa configurazione base abbiamo allontanato l'host, fino a variare la velocità in modo significativo ( anche di un fattore 1/20 ).
\\
Queste ultime configurazione sono state ampliate anche con l'uso della recv prima bloccante, e poi non bloccante.
Invece per quanto riguarda tutte le configurazioni a seguire abbiamo deciso di testare l'applicazione solo con la modalità della recv non bloccante. 
Questo è stato fatto perché i primi dati empirici erano stati raccolti in quel modo e non si voleva quindi andare ad alterare il risultato.
Avendo comunque analizzato separatamente il comportamento bloccante e non, possiamo dare una congettura di quello che può succedere in caso di comportamento non bloccante.
\\
Anche in questo caso, per ogni configurazione creata, ne abbiamo create altre in cui abbiamo scelto parametri diversi.
Quindi per ognuna è stata tenuta una determinata struttura e siamo andati a modificare un parametro alla volta, registrato tutti i dati ottenuti.
\\
Grazie a questo grande numero di possibili utilizzi, abbiamo raccolto sufficienti dati empirici. 


\end{subsection}




\begin{subsection}{Dettagli implementativi}
Avendo descritto quali parametri e quali configurazioni abbiamo descritto, ci concentriamo ora sulla parte implementativa dei test.
I principali problemi da risolvere in questa parte erano:
\begin{itemize}
 \item Velocità degli hosts.
 \item Salvataggio dei dati
 \item Elaborazione dei dati.
\end{itemize}
Per quanto riguarda la misurazione della velocità degli hosts, abbiamo creato una semplice applicazione che vada a misurarla.
Per realizzarla abbiamo creato una connessione tra due hosts, un client ed un server.
Abbiamo scelto di realizzare la applicazione tramite socket TCP; è stata comunque implementata anche la versione UDP. 
\\
Il client trasmette un file tramite Wi-Fi ed il server si mette in ascolto e calcola la velocità del client.
Il server è stato collegato all'AP tramite ethernet, e non wireless, per evitare di introdurre eventuali ritardi ed incognite.
Queste misurazioni sono state fatte all'interno della stessa sottorete, per non influenzare i risultati con la velocità della linea ADSL.
Nel server il calcolo è stato realizzato tramite la divisione tra il totale dei bit ricevuti e i secondi necessari per la ricezione.
Il totale dei bit è stato semplicemente ricavato dal totale di tutti i Byte ricevuti, moltiplicati per 8.
I secondi, invece, sono stati ottenuti catturando il tempo prima dell'inizio della ricezione e appena finita la ricezione ( tramite la \emph{time(NULL)} ).
Successivamente è stata fatta la differenza tra i due time ed è stata calcolata la velocità in Mb/s.
Successivamente, alla fine della ricezione di tutti i Byte, è stato catturato il tempo.
\\
La velocità che è stata rilevata non può essere considerata perfetta in quanto ci potrebbero alcuni fattori che possono andare ad alterarla. 
Possiamo però darla per buona perché, per ogni host, è stata misurata più volte ed è stata successivamente scelta la media. 
Inoltre è stata misurata, nella maggior parte dei casi, in una zona poco abitata e di sera o notte, quindi l'interferenza data da altri dispositivi era minima.
\\

Per quanta riguarda il salvataggio dei dati, abbiamo scelto di farlo in un file in formato \emph{JSON}.
Abbiamo scelto il JSON per la facilità di leggere i dati salvati. I dati sono stati salvati come un array di pacchetti, e per ogni pacchetto è stato salvato:
\begin{itemize}
 \item id del pacchetto
 \item millisecondi tra invio pacchetto e ricezione della notifica
 \item numero di tentativi di invio
 \item versione IP
 \item boolean per ack
 \item numero della configurazione
 \item data
 
\end{itemize}
I dati salvati sono i parametri di valutazione che abbiamo precedentemente scelto.
Per utilizzare il JSON all'interno di C abbiamo incluso una apposita libreria, la \emph{json/json.h}.
\\
Un esempio di file JSON è il seguente:



\begin{lstlisting}[language=json,firstnumber=1]
{ "pacchetti": [ 

	{ "testId": 4713, "type": 6, "ack": true, "time": 0, "retrycount": 0, "ipVersion": "ipv6", "date": "Sat Jun 20 22:53:38 2015\n" },
	{ "testId": 4714, "type": 6, "ack": true, "time": 6, "retrycount": 0, "ipVersion": "ipv6", "date": "Sat Jun 20 22:53:38 2015\n" },
	{ "testId": 4715, "type": 6, "ack": true, "time": 4, "retrycount": 0, "ipVersion": "ipv6", "date": "Sat Jun 20 22:53:38 2015\n" },
	{ "testId": 4716, "type": 6, "ack": true, "time": 11, "retrycount": 0, "ipVersion": "ipv6", "date": "Sat Jun 20 22:53:38 2015\n" },
	{ "testId": 4717, "type": 6, "ack": true, "time": 0, "retrycount": 0, "ipVersion": "ipv6", "date": "Sat Jun 20 22:53:38 2015\n" },
	{ "testId": 4718, "type": 6, "ack": true, "time": 6, "retrycount": 0, "ipVersion": "ipv6", "date": "Sat Jun 20 22:53:38 2015\n" }
  ]
}


\end{lstlisting}
\\


Grazie all'utilizzo di un file JSON per il salvataggio dei dati, ne risulta più semplice l'analisi.
Per poter elaborare i dati abbiamo scelto di creare vari script utilizzando il linguaggio \emph{Python}. 
È stato scelto il Python perché supporta il JSON e perché permette di effettuare tutte le operazioni necessarie in poche righe.
\\
Sono stati realizzati diversi script per svolgere diversi compiti. Ogni script ha uno scopo specifico ( ad esempio calcolare la media dei tempi di notifica, oppure il numero di nack ricevuti ).
Ad ogni script, a meno di casi particolari, viene passato il file JSON ed il numero di configurazione.
Ognuno di questi script andrà ad aprire il file di log, nel quale sono salvati tutti i dati.
Una volta aperto, viene convertito in una serie di elementi di un array JSON.
Ora, grazie alla configurazione passato da comando, sarà possibile andare ad analizzare i dati.
Ad esempio, il file Python per calcolare la media dei tempi di notifica di una certa configurazione è:


\begin{lstlisting}[language=python]
#!/usr/bin/python
# -*- coding: UTF-8 -*-
# all_avg_time.py
import json
import sys

tipo=-1
nPkt=0
numRetry=0
try:
	inputFile=sys.argv[1]
	tipo=int(sys.argv[2])
except:
	sys.exit("missing argument")

with open(inputFile) as data_file:    
    data = json.load(data_file)

for el in data["pacchetti"]:
	if el['type']==tipo:
		if el['ack']== True :
			numRetry=numRetry+el['retrycount']
			nPkt=nPkt+1	
	
avg=float(numRetry)/float(nPkt)
print(avg)


\end{lstlisting}

Sfruttando gli script che abbiamo realizzato siamo in grado di esprimere delle valutazioni su ogni aspetto che volevamo prendere in considerazione.


\end{subsection}


\begin{subsection}{Test effettuati}
Per effettuare i test ci siamo basati sui parametri e sulle configurazioni scelti precedentemente. 
La disposizione tipica della rete è quella in figura~\ref{fig:salaMengo}.


\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{salaMengo}
    \caption{Disposizione dei dispositivi maggiormente utilizzata. R1 ed R2 sono i Raspberry, mentre U è la UDOO.}
     \label{fig:salaMengo}
\end{figure}

In particolare, è stato usato il computer HP per svolgere la maggior parte dei test. 
Per creare del traffico in rete, invece, sono stati generalmente utilizzati il Raspberry Pi 2, la UDOO ed il Raspberry Model B, con l'eventuale aggiunta di altri dispositivi ( come altri portatili o tablet ).
Come server sono stati usati o il Raspberry Model B oppure altri computer.
\\
Le prove sono state svolte principalmente a casa, ma anche presso il laboratorio Ercolani.
Non sono state fatte prove attraverso la rete \emph{ALMAWIFI} in quanto gli access point bloccavano la comunicazione.
Per ovviare al problema è stata creata un rete locale con l'uso del ZyXEL descritto precedentemente.

 
 
 
\end{subsection}


\end{section}


\begin{section}{Analisi dei risultati}
Andiamo ora ad analizzare i risultati ottenuti.
Le analisi che abbiamo effettuato riguardano la qualità della trasmissione, i tempi medi di ricezione di una notifica proveniente dall'access point, il numero medio di NACK ricevuti e la media dei retry per l'invio dei pacchetti.
Andremo anche ad aggiungere una ulteriore analisi per la configurazione in movimento, che saranno i \emph{burst NACK} ( ovvero quanti NACK consecutivi sono notificati ).


Per ogni parametro che vogliamo valutare andremo a stabilire quanto può incidere nella trasmissione, lasciando inalterati tutti gli altri parametri.


%MENGO: aggiungere che abbiamo messo solo alcuni dati,



\begin{subsection}{Confronto tra IPv4 e IPv6}
  
  
  Per quanto riguarda IPv4 ed IPv6, andiamo ad analizzare i risultati relativi ai tempi di ricezioni della notifica proveniente dall'access point, la media dei \emph{NACK} e la media dei retry.
  In particolare si possono notare le medie dei tempi di IPv4 nella tabella ~\ref{tab:AvgTimeIPv4} mentre quella di IPv6 nella tabella ~\ref{tab:AvgTimeIPv6}.
  Poi faccio i confronti anche con gli altri e ci metto le tabelle. Dopo aver messo le tabelle commento quei cazzo di risultati.

  \begin{table}[h]
  \centering
  \caption{Media dei tempi relativi all'utilizzo di IPv4}
  \label{tab:AvgTimeIPv4}
  \begin{tabular}{|l|c|c|c|c|c|}
  \hline
  IPv4  & Conf. 5 & Conf. 6 & Conf. 7  & Conf. 8 & Conf. 9 \\ \hline
  prima  & 6.234  & 5.624 & 5.5952 & 2.8068  & 4.9292\\ \hline
  seconda & 7.8972  & 5.2736 & 4.7432  & 4.5024 &  2.9844\\ \hline
  terza & 7.3208 & 2.0812 & 4.0432 & 6.0316 & 4.7292\\ \hline
  quarta & 7.627 & 5.906  & 3.4704 & 5.7504 & 6.7728  \\ \hline \hline
  Media & 7.26975 & 4.7212  & 4.463 & 4.7728 & 4.8539  \\ \hline
  \end{tabular}
  \end{table}


  \begin{table}[h]
  \centering
  \caption{Media dei tempi relativi all'utilizzo di IPv6}
  \label{tab:AvgTimeIPv6}
  \begin{tabular}{|l|c|c|c|c|c|}
  \hline
  IPv6  & Conf. 5 & Conf. 6 & Conf. 7  & Conf. 8 & Conf. 9 \\ \hline
  prima  & 5.44  & 6.508 & 4.9788 & 5.338 & 6.2316 \\ \hline
  seconda & 6.8998  & 6.5516 & 5.5684  & 4.5024 & 4.7456 \\ \hline
  terza & 6.177 & 7.6788 & 5.9008 & 6.0316 &  6.1744 \\ \hline
  quarta & 5.9642 & 5.6636  & 4.9396 & 5.5612 & 4.0648 \\ \hline \hline
  Media & 6.12025 & 6.6005  & 5.3469 & 5.3583 & 5.3041 \\ \hline
  \end{tabular}
  \end{table}

  Guardando le medie dei tempi si può notare come non ci sia una sostanziale differenza tra le due versioni. 
  Questo è ragionevole in quanto sono stati testati pacchetti di dimensione ridotta, in modo da non avere frammentazione.
  Si possono ora controllare anche le statistiche relative al numero di retry dei pacchetti che ricevono ACK, sia per IPv4 che per IPv6.
  Ci si aspetta anche in questo caso che i valori siano simili.

  \begin{table}[h]
  \centering
  \caption{Media dei retry relativi all'utilizzo di IPv4}
  \label{tab:AvgRetryIPv4}
  \begin{tabular}{|l|c|c|c|c|c|}
  \hline
  IPv4  & Conf. 5 & Conf. 6 & Conf. 7  & Conf. 8 & Conf. 9 \\ \hline
  prima  & 0.03962  & 0.156 & 0.26683 & 0.13731  & 0.127105\\ \hline
  seconda & 0.08884 & 0.16 & 0.1312  & 0.077787 &  0.14097\\ \hline
  terza & 0.08545 & 0.246894 & 0.193264 & 0.1642628 & 0.134454\\ \hline
  quarta & 0.093838 & 0.1536  & 0.242983 & 0.108844 & 0.15459  \\ \hline \hline
  Media & 0.076937 & 0.1791235  &  0.20856925 & 0.12205095 & 0.13927975  \\ \hline
  \end{tabular}
  \end{table}


  \begin{table}[h]
  \centering
  \caption{Media dei retry relativi all'utilizzo di IPv6}
  \label{tab:AvgRetryIPv6}
  \begin{tabular}{|l|c|c|c|c|c|}
  \hline
  IPv6  & Conf. 5 & Conf. 6 & Conf. 7  & Conf. 8 & Conf. 9 \\ \hline
  prima  & 0.09  & 0.14646 & 0.12902 & 0.11765 & 0.1432\\ \hline
  seconda & 0.06521  & 0.0748 & 0.11774  & 0.1144 & 0.17508 \\ \hline
  terza & 0.04641 & 0.0556 & 0.096 & 0.11307 &  0.1484\\ \hline
  quarta & 0.06687 & 0.05682  & 0.08109 & 0.1508 & 0.120144 \\ \hline \hline
  Media & 0.0671225 & 0.08342  & 0.1059625 & 0.12398 & 0.146706  \\ \hline
  \end{tabular}
  \end{table}


  Analizzando le medie dei retry dalle tabelle~\ref{tab:AvgRetryIPv4} e~\ref{tab:AvgRetryIPv6} possiamo osservare che effettivamente non ci sono sostanziali differenze.
  L'unica differenza di configurazione è ottenuta nella Conf. 6, ma è dovuta principalmente ad una prova che ha alzato il valore.
  Visto che una singola prova può essere rallentata da diversi fattori, possiamo valutare le diverse versioni come identiche in caso di mancata frammentazione.
  %MENGO: conviene (e ha senso)  dire che l'app potrebbe decidere di mandare in IPv4 o ipv6 se si accorge di comportamenti strani (tipo rallentati in ipv4) in casi di frammentazione??? 
  %MENGO: dire che valutiamo anche cosa può fare la applicazione
\end{subsection}

\begin{subsection}{Valutazione problemi dovuti a pacchetti nella rete} %MENGO: titolo del cazzo
  Una seconda osservazione si può fare su una attenta analisi riguardo al numero di pacchetti e di hosts sulla rete.
  In particolare vogliamo analizzare i tempi, i NACK ed i retry relativi alla presenza di un host che trasmette N pacchetti rispetto a K hosts che trasmettono N/K pacchetti ciascuno.
  La prove sono state effettuate con il nodo da solo nella rete, un host sulla rete che trasmette 71 MB, due hosts che trasmettono 36 MB ciascuno e tre hosts che trasmettono 22 MB ciascuno.




  \begin{table}[h]
  \centering
  \caption{Media dei tempi rispetto al numero di pacchetti}
  \label{tab:AvgTimePkts}
  \begin{tabular}{|l|c|c|c|c|c|}
  \hline
  IPv6  & Conf. 5 & Conf. 6 & Conf. 7  & Conf. 8 & Conf. 9 \\ \hline
  prima  & 0.09  & 0.14646 & 0.12902 & 0.11765 & 0.1432\\ \hline
  seconda & 0.06521  & 0.0748 & 0.11774  & 0.1144 & 0.17508 \\ \hline
  terza & 0.04641 & 0.0556 & 0.096 & 0.11307 &  0.1484\\ \hline
  quarta & 0.06687 & 0.05682  & 0.08109 & 0.1508 & 0.120144 \\ \hline \hline
  Media & 0.0671225 & 0.08342  & 0.1059625 & 0.12398 & 0.146706  \\ \hline
  \end{tabular}
  \end{table}

  Analizzando i tempi della tabella~\ref{tab:AvgTimePkts} si può notare che 

  \begin{table}[h]
  \centering
  \caption{Media dei retry rispetto al numero di pacchetti}
  \label{tab:AvgRetryPkts}
  \begin{tabular}{|l|c|c|c|c|c|}
  \hline
  IPv6  & Conf. 5 & Conf. 6 & Conf. 7  & Conf. 8  \\ \hline
  prima  & 0.09  & 0.14646 & 0.12902 & 0.11765 \\ \hline
  seconda & 0.06521  & 0.0748 & 0.11774  & 0.1144  \\ \hline
  terza & 0.04641 & 0.0556 & 0.096 & 0.11307 \\ \hline
  quarta & 0.06687 & 0.05682  & 0.08109 & 0.1508  \\ \hline \hline
  Media & 0.0671225 & 0.08342  & 0.1059625 & 0.12398   \\ \hline
  \end{tabular}
  \end{table}







  
\end{subsection}


\begin{subsection}{Valutazione interferenza traffico} %MENGO: altro titolo del cazzo
 
 asdfadsfs
 
 
\end{subsection}



\begin{subsection}{Problemi dovuti alla trasmissione in movimento}
 
 asdfadsfs
 
 
\end{subsection}
























  \begin{table}[h]
  \centering
  \caption{Tempi di ricezione di notifica in caso di recv bloccante}
  \label{WaitTable}
  \begin{tabular}{|l|c|c|c|c|}
  \hline
  WAIT  & Da solo  & Un host a 70Mb/s  & Un host a 10Mb/s  & Un host a 6 Mb/s \\ \hline
  prima  & 0.4736  & 0.6684 & 0.716 & 0.943 \\ \hline
  seconda & 0.4536  & 0.7096 & 1.027  & 0.7282  \\ \hline
  terza & 0.4716 & 0.6664 & 0.906 & 0.8855  \\ \hline
  quarta & 0.5296 & 0.6194  & 0.9864 & 1.2518  \\ \hline \hline
  Media & 0.4821 & 0.66595  & 0.90885 & 0.952125  \\ \hline
  \end{tabular}
  \end{table}



  \begin{table}[h]
  \centering
  \caption{Tabella no wait}
  \label{FirstTable2}
  \begin{tabular}{|l|c|c|c|c|}
  \hline
  NO WAIT ERRATA!!!  & Da solo  & Un host  & Due hosts  & Tre hosts \\ \hline
  prima  & 0.4736  & 0.6684 & 1.1236 & 0.6174 \\ \hline
  seconda & 0.4536  & 0.7096 & 1.2464  & 0.7282  \\ \hline
  terza & 0.4716 & 0.6664 & 0.906 & 0.8855  \\ \hline
  quarta & 0.5296 & 0.6194  & 0.9864 & 1.2518  \\ \hline \hline
  Media & 0.4821 & 0.66595  & 1.0656 & 0.870725  \\ \hline

  \end{tabular}
  \end{table}


\end{section}




\end{chapter}

%\end{document}
