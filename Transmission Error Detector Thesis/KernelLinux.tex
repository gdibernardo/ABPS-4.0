\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[italian]{babel}
\usepackage[latin1]{inputenc}
\usepackage{fancyhdr}
\usepackage{indentfirst}
\usepackage{graphicx}
\graphicspath{ {Images/}  }
\usepackage{newlfont}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amsthm}


\pagestyle{fancy}\addtolength{\headwidth}{20pt}
\renewcommand{\chaptermark}[1]{\markboth{\thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection \ #1}{}}
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\cfoot{}

\linespread{1.3}    

\begin{document}
\begin{chapter}{Cos'è un kernel}
Il kernel rappresenta il nucleo di un sistema operativo e racchiude tutte le funzioni principali del sistema stesso come gestione della memoria, gestione delle risorse, lo scheduling e il file system.
Le applicazioni in esecuzione nel sistema possono richiedere particolari servizi al kernel tramite chiamate di sistema ( system call ) senza accedere direttamente alle risorse fisiche.
L'accesso diretto all'hardware può risultare anche molto complesso pertanto il kernel implementa una o più astrazioni dell'hardware, il cosiddetto Hardware Abstraction Layer. Queste astrazioni servono a nascondere 
la complessità e a fornire un'interfaccia pulita ed omogenea dell'hardware sottostante.
\\I kernel si possono classificare in quattro categorie:
\begin{itemize}
\item \textbf{Kernel monolitici} un unico aggregato di procedure di gestione mutuamente coordinate e astrazioni hardware.
\item \textbf{Micro kernel} semplici astrazioni dell'hardware gestite e coordinate da un kernel minimale, basate su un paradigma client/server, e primitive di message passing.
\item \textbf{Kernel ibridi} simili a micro kernel con la sola differenza di eseguire alcune componenti del sistema in kernel space per questione di efficienza.
\item \textbf{Exo-kernel} non forniscono alcuna astrazione dell'hardware sottostante ma soltanto una collezione di librerie per mettere in contatto applicazioni con le risorse fisiche.
\end{itemize}
\begin{section}{Il kernel Linux}
Nell'aprile del 1991 Linus Torvalds, uno studente finlandese di informatica, comincia a sviluppare un semplice sistema operativo chiamato Linux.
\\
L'architettura del kernel sviluppato da Torvalds è di tipo monolitico a discapito di una struttura più moderna e flessibile come quella basata su micro kernel. 

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{KernelLinuxArchitectureImage}
    \caption{L'architettura del kernel Linux.}
     \label{fig:KernelLinuxArchitectureImage}
\end{figure}

Sebbene oggi il kernel possa essere compilato in modo da ottenere un'immagine binaria ridotta al minimo, e i driver possono essere caricati da moduli esterni, l'architettura originaria è chiaramente visibile: tutti i driver, infatti, devono avere una parte eseguita in kernel mode, anche quelli per cui ciò non sarebbe affatto necessario ( come ad esempio i driver dei file system ). 
\\
Attualmente il kernel Linux è distribuito con licenza GNU General Public License ed è in continua evoluzione grazie ad una vastissima comunità di sviluppatori da ogni parte del mondo che contribuisce attivamente al suo sviluppo. 
\\
Il kernel Linux trova larghissima diffusione ed utilizzo: infatti grazie alla sua flessibilità viene utilizzato dai personal computer ai grandi centri di calcolo, dai più moderni sistemi embedded agli smartphone.
\\
Android, il sistema mobile più diffuso al mondo, si basa su una versione lightweight del kernel Linux.

\end{section}
\begin{section}{Linux kernel v4.0}
Il 12 Aprile 2015 è stato rilasciata la versione 4.0 del kernel Linux. Il cambio di versione da 3.x a 4.0 non è dovuto a nessun particolare miglioramento del kernel: la nuova versione stabile sarebbe dovuta essere la 3.20 ma su proposta di Linus Torvalds si è deciso di incrementare la numerazione alla versione 4.0 per non creare confusione con numeri molto grandi. 
\\
La nuova versione del kernel, quindi, non introduce particolari nuove feature. Una delle novità degna di nota è pero il \emph{live patching}: ovvero la possibilità di installare pacchetti e estensioni al kernel senza dover riavviare la macchina. Questo può essere cruciale, ad esempio, per aspetti legati alla sicurezza.
\end{section}
\begin{section}{Linux networking}
I moduli del networking ( e relativi device driver ) occupano buona parte del codice del kernel Linux.
\\
Vi sono due strutture particolarmente importanti utilizzante largamente in tutto lo stack di rete del kernel Linux.
\begin{paragraph}{Socket buffer}
La struttura sk\_buff mantiene le informazioni relative a ciascun pacchetto inviato o ricevuto lungo lo stack di rete di Linux.
\\
La struttura socket buffer contiene diversi campi che memorizzano le informazioni del pacchetto come il puntatore alla queue a cui è accodato o il socket a cui è associato.
\\
Essendo lo stack di rete implementato su più livelli, dove ciascun layer aggiunge ( o rimuove ) delle proprie informazioni di intestazione ad un messaggio, mantenere per ogni livello di rete una struttura diversa per identificare un certo pacchetto appartenente a quel dato layer potrebbe risultare parecchio oneroso in termini di memoria in quanto si finirebbe per copiare grandi quantità di dati da un buffer ad un altro. Anche questo motivo, nel kernel Linux, si è deciso di mantenere un'unica struttura accessibile da qualsiasi layer dello stack di rete. 
\\
La struttura sk\_buff mantiene un union field per ciascun livello di rete dello stack TCP/IP ( trasporto, network, data-link ) dove ciascun campo ( h, nh, mac ) rappresenta un header di un protocollo di comunicazione adotabbile per quel livello.
\\
Il campo \emph{data} punta invece al payload del pacchetto che, però, può avere diversi significati a seconda del livello di rete trattato. Ad esempio in fase di ricezione di un pacchetto la funzione responsabile di trattare un datagram a livello network punterà all'header contenuto nel campo nh della struct socket buffer e il campo data sarà reinizializzato a partire dall'offset di inizio del payload per il livello rete perdendo così tutte le informazioni di intestazione ( e non ) memorizzate prima di quel offset (in ricezione il pacchetto sarà già stato trattato dai layer inferiori a quello attuale ).
\\
In fase di invio il procedimento è molto simile ma con la difficoltà di dover appendere eventuali header man mano che si percorre lo stack di rete verso il basso. A tale scopo vi è una funzione di manipolazione delle strutture sk\_buff chiamata \textbf{skb\_reserve}, in genere invocata dopo un allocazione di un socket buffer, che consente di riservare dello spazio per gli header dei diversi protocolli.
\end{paragraph}

\begin{paragraph}{struct net\_device} questa struttura rappresenta una scheda di rete, anche virtuale: può essere infatti che ci si riferisca ad una scheda di rete virtuale ottenuta dopo aver effettuato un \emph{bonding}, ovvero è possibile assegnare un unico indirizzo IP a due o più NIC ( vedendole così come un unico device ) in modo da migliorare le performance. 
\\
La struttura net\_device contiene campi che identificano l'interfaccia di rete come il valore massimo della sua MTU e l'indirizzo MAC.
\end{paragraph}

Nello sviluppo del progetto di tesi è stato esteso il comportamento del workflow del kernel Linux per quanto riguarda la trasmissione di un datagram UDP. Per tanto, qui di seguito, descriveremo brevemente buona parte dei moduli che rendono possibile la trasmissione di un pacchetto UDP a partire da un applicazione fino al device driver.
\\
Quando viene invocata una routine che interagisce con la rete tramite socket  ( come ad esempio send, sendto o sendmsg ) il controllo viene passato al \emph{socket interface layer}: se il socket è di tipo TCP il controllo verrà dato alla funzione tcp\_sendmsg altrimenti, se di tipo UDP, alla primitiva udp\_sendmsg.
\\
Appena il flusso dell'esecuzione è passatto alla routine udp\_sendmsg vengono effettuati alcuni controlli sui parametri passati come ad esempio sulla lunghezza specificata per il payload del datagram UDP o sugli indirizzi mittente e destinatario e le porte. Dopodiché, a seconda se specificato il flag UDP\_CORK o meno ( che consente quando abilitato tramite la system call \emph{setsockopt} di accumulare tutti i dati in output sul socket e inviarli in unico datagram quando disabilitato ), il controllo dell'esecuzione passerà alla primitiva di livello rete ip\_append\_data() oppure a ip\_skb\_make() che in entrambi casi, comunque, si appoggeranno sulla funzione \_\_ip\_append\_data() che tra le altre cose si occuperà di bufferizzare tutte le richieste di tramissione e di generare uno o più sk\_buff rappresentanti ciascun pacchetto ( o frammento ) IP. 
\\
A questo punto il flusso esecutivo torna a livello trasporto dove a un certo punto verrà invocata la primitiva udp\_push\_pending\_frames che genera l'header UDP e passa definitivamente il controllo a livello rete invocando la funzione ip\_push\_pending\_frame(). 
\\
In ip\_push\_pending\_frame() verrà generato l'header IP per ogni socket buffer in coda sul buffer in uscita per quel socket e dopo diversi controlli se il datagram IP necessita di frammentazione la funzione ip\_fragment si occuperà di frammentare il pacchetto IP in diverse strutture di tipo sk\_buff. 
\\
Tra i compiti a carico del livello network dello stack di rete vi è quello del \emph{routing}: in particolare a supporto del routing a livello rete vi è la funzione ip\_route\_output\_flow. 
\\
Se la fase di routing termina con successo verrà invocata la funzione di livello \emph{data-link} dev\_queue\_xmit() che, se l'interfaccia richiesta per la trasmissione è attiva, accoderà il socket buffer nella coda in uscita del net\_ device associato all' sk\_buff in invio e invocherà la funzione dev\_hard\_start\_xmit per cominciare a processare l'invio di un sk\_buff. 
\\
Nel caso di un interfaccia di rete \emph{softMAC}, ovvero che il MLME ( MAC Sublayer Management Entity, ovvero dove viene implementata la logica del Medium Access Control ) è implementato via software ( vi sono dispositivi detti \emph{fullMAC} che implementano il MLME direttamente in hardware ) questa funzione si appoggerà sul sottosistema mac80211.

\begin{paragraph}{Sottosistema mac80211}Il sottosistema mac80211 è stato rilasciato nel 2005 e si occupa di implementare la logica MLME per device softMAC interpretando e generando frame IEEE 802.11. Prima della sua adozione all'interno del kernel Linux la gestione e l'implementazione di IEEE 802.11 era lasciata ai device driver.
\\
Oggi la maggior parte dei device supportano questo sistema e in molti dei vecchi dispositivi i device driver sono stati riscritti tenendo conto di esso.
\\
In fase di trasmissione di un messaggio il controllo dal livello data-link viene ceduto al sottosistema mac80211 invocando la sua entry-point ieee \textbf{ieee80211\_xmit} che tra le altre cose si occupa dell'inizializzazione del frame 802.11 e del suo header. Per far ciò il sottosistema mac80211 si serve di una serie di handler appositamente settati, tra cui: 
\begin{itemize}
\item \textbf{ieee80211\_tx\_h\_dynamic\_ps} per la gestione del power saving.
\item \textbf{ieee80211\_tx\_h\_select\_key} si occupa di selezionare una chiave di cifratura. 
\item \textbf{ieee80211\_tx\_h\_michael\_mic\_add} si occupa di aggiungere il Message Integrity Code al frame IEEE 802.11.
\item \textbf{ieee80211\_tx\_h\_rate\_ctrl} che seleziona il bit rate con la quale il frame IEEE 802.11 deve essere trasmesso.
\item \textbf{ieee80211\_tx\_h\_sequence} calcola il \emph{sequence number} del frame e lo assegna all'header 802.11.
\item \textbf{ieee80211\_tx\_h\_fragment} si occupa, eventualmente, di frammentare il frame IEEE 802.11 in base al valore della MTU della scheda di rete wireless e a quella dell'access point.
\item \textbf{ieee80211\_tx\_h\_encrypt} cifra il frame IEEE 802.11 con l'algoritmo designato.
\item \textbf{ieee80211\_tx\_h\_calculate\_duration} si occupa di calcolare il campo \emph{duration} del frame IEEE 802.11 che indica per quanto tempo il canale sarà impegnato dalla trasmissione del frame.
\item \textbf{ieee80211\_tx\_h\_stats} setta una serie di variabili utili al mantenimento di alcune statistiche di trasmissione.
\end{itemize}
Una volta che il frame IEEE 802.11 è stato trasmesso la struttura socket buffer associata non viene immediatamente deallocata: mac80211 provvederà a ritrasmettere il messaggio per un certo numero di volte, dipendente dalla NIC e dallo stato in cui si trova la rete alla quale è connessa, qualora non dovesse ricevere l'ACK relativo a quel frame.
\\
Alla fine di questo processo viene invocata la routine ieee80211\_tx\_h\_status che fornisce alcune informazioni riguardanti l'esito della trasmissione per un certo pacchetto come ad esempio quante volte il pacchetto è stato ritrasmesso e se è stato effettivamente consegnato o meno all'access point.
\\
A questo punto sia che il frame IEEE 802.11 sia stato ricevuto dal first-hop o meno il socket buffer associato viene definitivamente deallocato.
\end{paragraph}
\end{section}
\end{chapter}
\end{document}